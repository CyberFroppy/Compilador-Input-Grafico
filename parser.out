Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DOT
    CHAR
    THEN
    DO
    WRITE
    READ

Grammar

Rule 0     S' -> programa
Rule 1     programa -> PROGRAM ID SEMICOLON vars module main
Rule 2     programa -> PROGRAM ID SEMICOLON module main
Rule 3     programa -> PROGRAM ID SEMICOLON vars main
Rule 4     programa -> PROGRAM ID SEMICOLON main
Rule 5     main -> MAIN bloque_module
Rule 6     vars -> VAR vars_aux
Rule 7     vars_aux -> vars_aux2 vars_aux
Rule 8     vars_aux -> vars_aux2
Rule 9     vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON
Rule 10    tipo -> INT n_seen_type
Rule 11    tipo -> FLOAT n_seen_type
Rule 12    bloque_module -> LBRACKET estatuto_module_aux RBRACKET
Rule 13    bloque_module -> LBRACKET RBRACKET
Rule 14    estatuto_module_aux -> estatuto_module estatuto_module_aux
Rule 15    estatuto_module_aux -> estatuto_module
Rule 16    estatuto_module -> estatuto
Rule 17    estatuto_module -> vars
Rule 18    bloque -> LBRACKET estatuto_aux RBRACKET
Rule 19    bloque -> LBRACKET RBRACKET
Rule 20    estatuto_aux -> estatuto estatuto_aux
Rule 21    estatuto_aux -> estatuto
Rule 22    estatuto -> asignacion SEMICOLON
Rule 23    estatuto -> condicion SEMICOLON
Rule 24    estatuto -> escritura SEMICOLON
Rule 25    estatuto -> return SEMICOLON
Rule 26    estatuto -> for SEMICOLON
Rule 27    estatuto -> while SEMICOLON
Rule 28    asignacion -> ID EQUAL expresion
Rule 29    expresion -> exp AND expresion
Rule 30    expresion -> exp
Rule 31    exp -> exp_aux OR exp
Rule 32    exp -> exp_aux
Rule 33    exp_aux -> exp_aux2 GREATERT exp_aux2
Rule 34    exp_aux -> exp_aux2 LESST exp_aux2
Rule 35    exp_aux -> exp_aux2 NOTEQUAL exp_aux2
Rule 36    exp_aux -> exp_aux2 DBEQUALS exp_aux2
Rule 37    exp_aux -> exp_aux2
Rule 38    exp_aux2 -> term PLUS exp_aux2
Rule 39    exp_aux2 -> term MINUS exp_aux2
Rule 40    exp_aux2 -> term
Rule 41    term -> factor MULTIPLY term
Rule 42    term -> factor DIVIDE term
Rule 43    term -> factor
Rule 44    factor -> LPAREN expresion RPAREN
Rule 45    factor -> CTEINT
Rule 46    factor -> CTEF
Rule 47    factor -> ID
Rule 48    module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module
Rule 49    module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module module
Rule 50    module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module
Rule 51    module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module
Rule 52    return -> RETURN expresion
Rule 53    for -> FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET
Rule 54    while -> WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET
Rule 55    condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque
Rule 56    condicion -> IF LPAREN expresion RPAREN bloque
Rule 57    escritura -> PRINT LPAREN escritura_aux RPAREN
Rule 58    escritura_aux -> expresion COMA escritura_aux
Rule 59    escritura_aux -> CTESTRING COMA escritura_aux
Rule 60    escritura_aux -> expresion
Rule 61    escritura_aux -> CTESTRING
Rule 62    n_seen_type -> <empty>
Rule 63    n_seen_var_name -> <empty>
Rule 64    n_seen_func_name -> <empty>
Rule 65    n_set_var_type -> <empty>

Terminals, with rules where they appear

AND                  : 29
CHAR                 : 
COLON                : 9
COMA                 : 58 59
COMMENT              : 
CTEF                 : 46
CTEINT               : 45 53
CTESTRING            : 59 61
DBEQUALS             : 36
DIVIDE               : 42
DO                   : 
DOT                  : 
ELSE                 : 55
EQUAL                : 28
FLOAT                : 11
FOR                  : 53
GREATERT             : 33
ID                   : 1 2 3 4 9 28 47 48 49 50 51
IF                   : 55 56
INT                  : 10
LBRACKET             : 12 13 18 19 53 54
LESST                : 34
LPAREN               : 44 48 49 50 51 54 55 56 57
MAIN                 : 5
MINUS                : 39
MODULE               : 48 49 50 51
MULTIPLY             : 41
NOTEQUAL             : 35
OR                   : 31
PLUS                 : 38
PRINT                : 57
PROGRAM              : 1 2 3 4
RBRACKET             : 12 13 18 19 53 54
READ                 : 
RETURN               : 52
RPAREN               : 44 48 49 50 51 54 55 56 57
SEMICOLON            : 1 2 3 4 9 22 23 24 25 26 27
THEN                 : 
TO                   : 53
VAR                  : 6
VOID                 : 48 50
WHILE                : 54
WRITE                : 
error                : 

Nonterminals, with rules where they appear

asignacion           : 22 53
bloque               : 55 55 56
bloque_module        : 5 48 49 50 51
condicion            : 23
escritura            : 24
escritura_aux        : 57 58 59
estatuto             : 16 20 21 53 54
estatuto_aux         : 18 20
estatuto_module      : 14 15
estatuto_module_aux  : 12 14
exp                  : 29 30 31
exp_aux              : 31 32
exp_aux2             : 33 33 34 34 35 35 36 36 37 38 39
expresion            : 28 29 44 52 54 55 56 58 60
factor               : 41 42 43
for                  : 26
main                 : 1 2 3 4
module               : 1 2 48 49
n_seen_func_name     : 48 49 50 51
n_seen_type          : 10 11 48 50
n_seen_var_name      : 9
n_set_var_type       : 9
programa             : 0
return               : 25
term                 : 38 39 40 41 42
tipo                 : 9 49 51
vars                 : 1 3 17
vars_aux             : 6 7
vars_aux2            : 7 8
while                : 27

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . PROGRAM ID SEMICOLON vars module main
    (2) programa -> . PROGRAM ID SEMICOLON module main
    (3) programa -> . PROGRAM ID SEMICOLON vars main
    (4) programa -> . PROGRAM ID SEMICOLON main

    PROGRAM         shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> PROGRAM . ID SEMICOLON vars module main
    (2) programa -> PROGRAM . ID SEMICOLON module main
    (3) programa -> PROGRAM . ID SEMICOLON vars main
    (4) programa -> PROGRAM . ID SEMICOLON main

    ID              shift and go to state 3


state 3

    (1) programa -> PROGRAM ID . SEMICOLON vars module main
    (2) programa -> PROGRAM ID . SEMICOLON module main
    (3) programa -> PROGRAM ID . SEMICOLON vars main
    (4) programa -> PROGRAM ID . SEMICOLON main

    SEMICOLON       shift and go to state 4


state 4

    (1) programa -> PROGRAM ID SEMICOLON . vars module main
    (2) programa -> PROGRAM ID SEMICOLON . module main
    (3) programa -> PROGRAM ID SEMICOLON . vars main
    (4) programa -> PROGRAM ID SEMICOLON . main
    (6) vars -> . VAR vars_aux
    (48) module -> . MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module
    (49) module -> . MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module module
    (50) module -> . MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module
    (51) module -> . MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module
    (5) main -> . MAIN bloque_module

    VAR             shift and go to state 8
    MODULE          shift and go to state 9
    MAIN            shift and go to state 10

    vars                           shift and go to state 5
    module                         shift and go to state 6
    main                           shift and go to state 7

state 5

    (1) programa -> PROGRAM ID SEMICOLON vars . module main
    (3) programa -> PROGRAM ID SEMICOLON vars . main
    (48) module -> . MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module
    (49) module -> . MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module module
    (50) module -> . MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module
    (51) module -> . MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module
    (5) main -> . MAIN bloque_module

    MODULE          shift and go to state 9
    MAIN            shift and go to state 10

    module                         shift and go to state 11
    main                           shift and go to state 12

state 6

    (2) programa -> PROGRAM ID SEMICOLON module . main
    (5) main -> . MAIN bloque_module

    MAIN            shift and go to state 10

    main                           shift and go to state 13

state 7

    (4) programa -> PROGRAM ID SEMICOLON main .

    $end            reduce using rule 4 (programa -> PROGRAM ID SEMICOLON main .)


state 8

    (6) vars -> VAR . vars_aux
    (7) vars_aux -> . vars_aux2 vars_aux
    (8) vars_aux -> . vars_aux2
    (9) vars_aux2 -> . ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON

    ID              shift and go to state 16

    vars_aux                       shift and go to state 14
    vars_aux2                      shift and go to state 15

state 9

    (48) module -> MODULE . VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module
    (49) module -> MODULE . tipo ID n_seen_func_name LPAREN RPAREN bloque_module module
    (50) module -> MODULE . VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module
    (51) module -> MODULE . tipo ID n_seen_func_name LPAREN RPAREN bloque_module
    (10) tipo -> . INT n_seen_type
    (11) tipo -> . FLOAT n_seen_type

    VOID            shift and go to state 17
    INT             shift and go to state 19
    FLOAT           shift and go to state 20

    tipo                           shift and go to state 18

state 10

    (5) main -> MAIN . bloque_module
    (12) bloque_module -> . LBRACKET estatuto_module_aux RBRACKET
    (13) bloque_module -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 22

    bloque_module                  shift and go to state 21

state 11

    (1) programa -> PROGRAM ID SEMICOLON vars module . main
    (5) main -> . MAIN bloque_module

    MAIN            shift and go to state 10

    main                           shift and go to state 23

state 12

    (3) programa -> PROGRAM ID SEMICOLON vars main .

    $end            reduce using rule 3 (programa -> PROGRAM ID SEMICOLON vars main .)


state 13

    (2) programa -> PROGRAM ID SEMICOLON module main .

    $end            reduce using rule 2 (programa -> PROGRAM ID SEMICOLON module main .)


state 14

    (6) vars -> VAR vars_aux .

    MODULE          reduce using rule 6 (vars -> VAR vars_aux .)
    MAIN            reduce using rule 6 (vars -> VAR vars_aux .)
    VAR             reduce using rule 6 (vars -> VAR vars_aux .)
    ID              reduce using rule 6 (vars -> VAR vars_aux .)
    IF              reduce using rule 6 (vars -> VAR vars_aux .)
    PRINT           reduce using rule 6 (vars -> VAR vars_aux .)
    RETURN          reduce using rule 6 (vars -> VAR vars_aux .)
    FOR             reduce using rule 6 (vars -> VAR vars_aux .)
    WHILE           reduce using rule 6 (vars -> VAR vars_aux .)
    RBRACKET        reduce using rule 6 (vars -> VAR vars_aux .)


state 15

    (7) vars_aux -> vars_aux2 . vars_aux
    (8) vars_aux -> vars_aux2 .
    (7) vars_aux -> . vars_aux2 vars_aux
    (8) vars_aux -> . vars_aux2
    (9) vars_aux2 -> . ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON

  ! shift/reduce conflict for ID resolved as shift
    MODULE          reduce using rule 8 (vars_aux -> vars_aux2 .)
    MAIN            reduce using rule 8 (vars_aux -> vars_aux2 .)
    VAR             reduce using rule 8 (vars_aux -> vars_aux2 .)
    IF              reduce using rule 8 (vars_aux -> vars_aux2 .)
    PRINT           reduce using rule 8 (vars_aux -> vars_aux2 .)
    RETURN          reduce using rule 8 (vars_aux -> vars_aux2 .)
    FOR             reduce using rule 8 (vars_aux -> vars_aux2 .)
    WHILE           reduce using rule 8 (vars_aux -> vars_aux2 .)
    RBRACKET        reduce using rule 8 (vars_aux -> vars_aux2 .)
    ID              shift and go to state 16

  ! ID              [ reduce using rule 8 (vars_aux -> vars_aux2 .) ]

    vars_aux2                      shift and go to state 15
    vars_aux                       shift and go to state 24

state 16

    (9) vars_aux2 -> ID . n_seen_var_name COLON tipo n_set_var_type SEMICOLON
    (63) n_seen_var_name -> .

    COLON           reduce using rule 63 (n_seen_var_name -> .)

    n_seen_var_name                shift and go to state 25

state 17

    (48) module -> MODULE VOID . n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module
    (50) module -> MODULE VOID . n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module
    (62) n_seen_type -> .

    ID              reduce using rule 62 (n_seen_type -> .)

    n_seen_type                    shift and go to state 26

state 18

    (49) module -> MODULE tipo . ID n_seen_func_name LPAREN RPAREN bloque_module module
    (51) module -> MODULE tipo . ID n_seen_func_name LPAREN RPAREN bloque_module

    ID              shift and go to state 27


state 19

    (10) tipo -> INT . n_seen_type
    (62) n_seen_type -> .

    ID              reduce using rule 62 (n_seen_type -> .)
    SEMICOLON       reduce using rule 62 (n_seen_type -> .)

    n_seen_type                    shift and go to state 28

state 20

    (11) tipo -> FLOAT . n_seen_type
    (62) n_seen_type -> .

    ID              reduce using rule 62 (n_seen_type -> .)
    SEMICOLON       reduce using rule 62 (n_seen_type -> .)

    n_seen_type                    shift and go to state 29

state 21

    (5) main -> MAIN bloque_module .

    $end            reduce using rule 5 (main -> MAIN bloque_module .)


state 22

    (12) bloque_module -> LBRACKET . estatuto_module_aux RBRACKET
    (13) bloque_module -> LBRACKET . RBRACKET
    (14) estatuto_module_aux -> . estatuto_module estatuto_module_aux
    (15) estatuto_module_aux -> . estatuto_module
    (16) estatuto_module -> . estatuto
    (17) estatuto_module -> . vars
    (22) estatuto -> . asignacion SEMICOLON
    (23) estatuto -> . condicion SEMICOLON
    (24) estatuto -> . escritura SEMICOLON
    (25) estatuto -> . return SEMICOLON
    (26) estatuto -> . for SEMICOLON
    (27) estatuto -> . while SEMICOLON
    (6) vars -> . VAR vars_aux
    (28) asignacion -> . ID EQUAL expresion
    (55) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque
    (56) condicion -> . IF LPAREN expresion RPAREN bloque
    (57) escritura -> . PRINT LPAREN escritura_aux RPAREN
    (52) return -> . RETURN expresion
    (53) for -> . FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET
    (54) while -> . WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET

    RBRACKET        shift and go to state 31
    VAR             shift and go to state 8
    ID              shift and go to state 41
    IF              shift and go to state 42
    PRINT           shift and go to state 43
    RETURN          shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    estatuto_module_aux            shift and go to state 30
    estatuto_module                shift and go to state 32
    estatuto                       shift and go to state 33
    vars                           shift and go to state 34
    asignacion                     shift and go to state 35
    condicion                      shift and go to state 36
    escritura                      shift and go to state 37
    return                         shift and go to state 38
    for                            shift and go to state 39
    while                          shift and go to state 40

state 23

    (1) programa -> PROGRAM ID SEMICOLON vars module main .

    $end            reduce using rule 1 (programa -> PROGRAM ID SEMICOLON vars module main .)


state 24

    (7) vars_aux -> vars_aux2 vars_aux .

    MODULE          reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    MAIN            reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    VAR             reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    ID              reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    IF              reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    PRINT           reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    RETURN          reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    FOR             reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    WHILE           reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)
    RBRACKET        reduce using rule 7 (vars_aux -> vars_aux2 vars_aux .)


state 25

    (9) vars_aux2 -> ID n_seen_var_name . COLON tipo n_set_var_type SEMICOLON

    COLON           shift and go to state 47


state 26

    (48) module -> MODULE VOID n_seen_type . ID n_seen_func_name LPAREN RPAREN bloque_module module
    (50) module -> MODULE VOID n_seen_type . ID n_seen_func_name LPAREN RPAREN bloque_module

    ID              shift and go to state 48


state 27

    (49) module -> MODULE tipo ID . n_seen_func_name LPAREN RPAREN bloque_module module
    (51) module -> MODULE tipo ID . n_seen_func_name LPAREN RPAREN bloque_module
    (64) n_seen_func_name -> .

    LPAREN          reduce using rule 64 (n_seen_func_name -> .)

    n_seen_func_name               shift and go to state 49

state 28

    (10) tipo -> INT n_seen_type .

    ID              reduce using rule 10 (tipo -> INT n_seen_type .)
    SEMICOLON       reduce using rule 10 (tipo -> INT n_seen_type .)


state 29

    (11) tipo -> FLOAT n_seen_type .

    ID              reduce using rule 11 (tipo -> FLOAT n_seen_type .)
    SEMICOLON       reduce using rule 11 (tipo -> FLOAT n_seen_type .)


state 30

    (12) bloque_module -> LBRACKET estatuto_module_aux . RBRACKET

    RBRACKET        shift and go to state 50


state 31

    (13) bloque_module -> LBRACKET RBRACKET .

    $end            reduce using rule 13 (bloque_module -> LBRACKET RBRACKET .)
    MODULE          reduce using rule 13 (bloque_module -> LBRACKET RBRACKET .)
    MAIN            reduce using rule 13 (bloque_module -> LBRACKET RBRACKET .)


state 32

    (14) estatuto_module_aux -> estatuto_module . estatuto_module_aux
    (15) estatuto_module_aux -> estatuto_module .
    (14) estatuto_module_aux -> . estatuto_module estatuto_module_aux
    (15) estatuto_module_aux -> . estatuto_module
    (16) estatuto_module -> . estatuto
    (17) estatuto_module -> . vars
    (22) estatuto -> . asignacion SEMICOLON
    (23) estatuto -> . condicion SEMICOLON
    (24) estatuto -> . escritura SEMICOLON
    (25) estatuto -> . return SEMICOLON
    (26) estatuto -> . for SEMICOLON
    (27) estatuto -> . while SEMICOLON
    (6) vars -> . VAR vars_aux
    (28) asignacion -> . ID EQUAL expresion
    (55) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque
    (56) condicion -> . IF LPAREN expresion RPAREN bloque
    (57) escritura -> . PRINT LPAREN escritura_aux RPAREN
    (52) return -> . RETURN expresion
    (53) for -> . FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET
    (54) while -> . WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET

    RBRACKET        reduce using rule 15 (estatuto_module_aux -> estatuto_module .)
    VAR             shift and go to state 8
    ID              shift and go to state 41
    IF              shift and go to state 42
    PRINT           shift and go to state 43
    RETURN          shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    estatuto_module                shift and go to state 32
    estatuto_module_aux            shift and go to state 51
    estatuto                       shift and go to state 33
    vars                           shift and go to state 34
    asignacion                     shift and go to state 35
    condicion                      shift and go to state 36
    escritura                      shift and go to state 37
    return                         shift and go to state 38
    for                            shift and go to state 39
    while                          shift and go to state 40

state 33

    (16) estatuto_module -> estatuto .

    VAR             reduce using rule 16 (estatuto_module -> estatuto .)
    ID              reduce using rule 16 (estatuto_module -> estatuto .)
    IF              reduce using rule 16 (estatuto_module -> estatuto .)
    PRINT           reduce using rule 16 (estatuto_module -> estatuto .)
    RETURN          reduce using rule 16 (estatuto_module -> estatuto .)
    FOR             reduce using rule 16 (estatuto_module -> estatuto .)
    WHILE           reduce using rule 16 (estatuto_module -> estatuto .)
    RBRACKET        reduce using rule 16 (estatuto_module -> estatuto .)


state 34

    (17) estatuto_module -> vars .

    VAR             reduce using rule 17 (estatuto_module -> vars .)
    ID              reduce using rule 17 (estatuto_module -> vars .)
    IF              reduce using rule 17 (estatuto_module -> vars .)
    PRINT           reduce using rule 17 (estatuto_module -> vars .)
    RETURN          reduce using rule 17 (estatuto_module -> vars .)
    FOR             reduce using rule 17 (estatuto_module -> vars .)
    WHILE           reduce using rule 17 (estatuto_module -> vars .)
    RBRACKET        reduce using rule 17 (estatuto_module -> vars .)


state 35

    (22) estatuto -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 52


state 36

    (23) estatuto -> condicion . SEMICOLON

    SEMICOLON       shift and go to state 53


state 37

    (24) estatuto -> escritura . SEMICOLON

    SEMICOLON       shift and go to state 54


state 38

    (25) estatuto -> return . SEMICOLON

    SEMICOLON       shift and go to state 55


state 39

    (26) estatuto -> for . SEMICOLON

    SEMICOLON       shift and go to state 56


state 40

    (27) estatuto -> while . SEMICOLON

    SEMICOLON       shift and go to state 57


state 41

    (28) asignacion -> ID . EQUAL expresion

    EQUAL           shift and go to state 58


state 42

    (55) condicion -> IF . LPAREN expresion RPAREN bloque ELSE bloque
    (56) condicion -> IF . LPAREN expresion RPAREN bloque

    LPAREN          shift and go to state 59


state 43

    (57) escritura -> PRINT . LPAREN escritura_aux RPAREN

    LPAREN          shift and go to state 60


state 44

    (52) return -> RETURN . expresion
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    expresion                      shift and go to state 61
    exp                            shift and go to state 62
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 45

    (53) for -> FOR . asignacion TO CTEINT LBRACKET estatuto RBRACKET
    (28) asignacion -> . ID EQUAL expresion

    ID              shift and go to state 41

    asignacion                     shift and go to state 71

state 46

    (54) while -> WHILE . LPAREN expresion RPAREN LBRACKET estatuto RBRACKET

    LPAREN          shift and go to state 72


state 47

    (9) vars_aux2 -> ID n_seen_var_name COLON . tipo n_set_var_type SEMICOLON
    (10) tipo -> . INT n_seen_type
    (11) tipo -> . FLOAT n_seen_type

    INT             shift and go to state 19
    FLOAT           shift and go to state 20

    tipo                           shift and go to state 73

state 48

    (48) module -> MODULE VOID n_seen_type ID . n_seen_func_name LPAREN RPAREN bloque_module module
    (50) module -> MODULE VOID n_seen_type ID . n_seen_func_name LPAREN RPAREN bloque_module
    (64) n_seen_func_name -> .

    LPAREN          reduce using rule 64 (n_seen_func_name -> .)

    n_seen_func_name               shift and go to state 74

state 49

    (49) module -> MODULE tipo ID n_seen_func_name . LPAREN RPAREN bloque_module module
    (51) module -> MODULE tipo ID n_seen_func_name . LPAREN RPAREN bloque_module

    LPAREN          shift and go to state 75


state 50

    (12) bloque_module -> LBRACKET estatuto_module_aux RBRACKET .

    $end            reduce using rule 12 (bloque_module -> LBRACKET estatuto_module_aux RBRACKET .)
    MODULE          reduce using rule 12 (bloque_module -> LBRACKET estatuto_module_aux RBRACKET .)
    MAIN            reduce using rule 12 (bloque_module -> LBRACKET estatuto_module_aux RBRACKET .)


state 51

    (14) estatuto_module_aux -> estatuto_module estatuto_module_aux .

    RBRACKET        reduce using rule 14 (estatuto_module_aux -> estatuto_module estatuto_module_aux .)


state 52

    (22) estatuto -> asignacion SEMICOLON .

    VAR             reduce using rule 22 (estatuto -> asignacion SEMICOLON .)
    ID              reduce using rule 22 (estatuto -> asignacion SEMICOLON .)
    IF              reduce using rule 22 (estatuto -> asignacion SEMICOLON .)
    PRINT           reduce using rule 22 (estatuto -> asignacion SEMICOLON .)
    RETURN          reduce using rule 22 (estatuto -> asignacion SEMICOLON .)
    FOR             reduce using rule 22 (estatuto -> asignacion SEMICOLON .)
    WHILE           reduce using rule 22 (estatuto -> asignacion SEMICOLON .)
    RBRACKET        reduce using rule 22 (estatuto -> asignacion SEMICOLON .)


state 53

    (23) estatuto -> condicion SEMICOLON .

    VAR             reduce using rule 23 (estatuto -> condicion SEMICOLON .)
    ID              reduce using rule 23 (estatuto -> condicion SEMICOLON .)
    IF              reduce using rule 23 (estatuto -> condicion SEMICOLON .)
    PRINT           reduce using rule 23 (estatuto -> condicion SEMICOLON .)
    RETURN          reduce using rule 23 (estatuto -> condicion SEMICOLON .)
    FOR             reduce using rule 23 (estatuto -> condicion SEMICOLON .)
    WHILE           reduce using rule 23 (estatuto -> condicion SEMICOLON .)
    RBRACKET        reduce using rule 23 (estatuto -> condicion SEMICOLON .)


state 54

    (24) estatuto -> escritura SEMICOLON .

    VAR             reduce using rule 24 (estatuto -> escritura SEMICOLON .)
    ID              reduce using rule 24 (estatuto -> escritura SEMICOLON .)
    IF              reduce using rule 24 (estatuto -> escritura SEMICOLON .)
    PRINT           reduce using rule 24 (estatuto -> escritura SEMICOLON .)
    RETURN          reduce using rule 24 (estatuto -> escritura SEMICOLON .)
    FOR             reduce using rule 24 (estatuto -> escritura SEMICOLON .)
    WHILE           reduce using rule 24 (estatuto -> escritura SEMICOLON .)
    RBRACKET        reduce using rule 24 (estatuto -> escritura SEMICOLON .)


state 55

    (25) estatuto -> return SEMICOLON .

    VAR             reduce using rule 25 (estatuto -> return SEMICOLON .)
    ID              reduce using rule 25 (estatuto -> return SEMICOLON .)
    IF              reduce using rule 25 (estatuto -> return SEMICOLON .)
    PRINT           reduce using rule 25 (estatuto -> return SEMICOLON .)
    RETURN          reduce using rule 25 (estatuto -> return SEMICOLON .)
    FOR             reduce using rule 25 (estatuto -> return SEMICOLON .)
    WHILE           reduce using rule 25 (estatuto -> return SEMICOLON .)
    RBRACKET        reduce using rule 25 (estatuto -> return SEMICOLON .)


state 56

    (26) estatuto -> for SEMICOLON .

    VAR             reduce using rule 26 (estatuto -> for SEMICOLON .)
    ID              reduce using rule 26 (estatuto -> for SEMICOLON .)
    IF              reduce using rule 26 (estatuto -> for SEMICOLON .)
    PRINT           reduce using rule 26 (estatuto -> for SEMICOLON .)
    RETURN          reduce using rule 26 (estatuto -> for SEMICOLON .)
    FOR             reduce using rule 26 (estatuto -> for SEMICOLON .)
    WHILE           reduce using rule 26 (estatuto -> for SEMICOLON .)
    RBRACKET        reduce using rule 26 (estatuto -> for SEMICOLON .)


state 57

    (27) estatuto -> while SEMICOLON .

    VAR             reduce using rule 27 (estatuto -> while SEMICOLON .)
    ID              reduce using rule 27 (estatuto -> while SEMICOLON .)
    IF              reduce using rule 27 (estatuto -> while SEMICOLON .)
    PRINT           reduce using rule 27 (estatuto -> while SEMICOLON .)
    RETURN          reduce using rule 27 (estatuto -> while SEMICOLON .)
    FOR             reduce using rule 27 (estatuto -> while SEMICOLON .)
    WHILE           reduce using rule 27 (estatuto -> while SEMICOLON .)
    RBRACKET        reduce using rule 27 (estatuto -> while SEMICOLON .)


state 58

    (28) asignacion -> ID EQUAL . expresion
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    expresion                      shift and go to state 76
    exp                            shift and go to state 62
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 59

    (55) condicion -> IF LPAREN . expresion RPAREN bloque ELSE bloque
    (56) condicion -> IF LPAREN . expresion RPAREN bloque
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    expresion                      shift and go to state 77
    exp                            shift and go to state 62
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 60

    (57) escritura -> PRINT LPAREN . escritura_aux RPAREN
    (58) escritura_aux -> . expresion COMA escritura_aux
    (59) escritura_aux -> . CTESTRING COMA escritura_aux
    (60) escritura_aux -> . expresion
    (61) escritura_aux -> . CTESTRING
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    CTESTRING       shift and go to state 80
    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    escritura_aux                  shift and go to state 78
    expresion                      shift and go to state 79
    exp                            shift and go to state 62
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 61

    (52) return -> RETURN expresion .

    SEMICOLON       reduce using rule 52 (return -> RETURN expresion .)


state 62

    (29) expresion -> exp . AND expresion
    (30) expresion -> exp .

    AND             shift and go to state 81
    SEMICOLON       reduce using rule 30 (expresion -> exp .)
    TO              reduce using rule 30 (expresion -> exp .)
    RPAREN          reduce using rule 30 (expresion -> exp .)
    COMA            reduce using rule 30 (expresion -> exp .)


state 63

    (31) exp -> exp_aux . OR exp
    (32) exp -> exp_aux .

    OR              shift and go to state 82
    AND             reduce using rule 32 (exp -> exp_aux .)
    SEMICOLON       reduce using rule 32 (exp -> exp_aux .)
    TO              reduce using rule 32 (exp -> exp_aux .)
    RPAREN          reduce using rule 32 (exp -> exp_aux .)
    COMA            reduce using rule 32 (exp -> exp_aux .)


state 64

    (33) exp_aux -> exp_aux2 . GREATERT exp_aux2
    (34) exp_aux -> exp_aux2 . LESST exp_aux2
    (35) exp_aux -> exp_aux2 . NOTEQUAL exp_aux2
    (36) exp_aux -> exp_aux2 . DBEQUALS exp_aux2
    (37) exp_aux -> exp_aux2 .

    GREATERT        shift and go to state 83
    LESST           shift and go to state 84
    NOTEQUAL        shift and go to state 85
    DBEQUALS        shift and go to state 86
    OR              reduce using rule 37 (exp_aux -> exp_aux2 .)
    AND             reduce using rule 37 (exp_aux -> exp_aux2 .)
    SEMICOLON       reduce using rule 37 (exp_aux -> exp_aux2 .)
    TO              reduce using rule 37 (exp_aux -> exp_aux2 .)
    RPAREN          reduce using rule 37 (exp_aux -> exp_aux2 .)
    COMA            reduce using rule 37 (exp_aux -> exp_aux2 .)


state 65

    (38) exp_aux2 -> term . PLUS exp_aux2
    (39) exp_aux2 -> term . MINUS exp_aux2
    (40) exp_aux2 -> term .

    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    GREATERT        reduce using rule 40 (exp_aux2 -> term .)
    LESST           reduce using rule 40 (exp_aux2 -> term .)
    NOTEQUAL        reduce using rule 40 (exp_aux2 -> term .)
    DBEQUALS        reduce using rule 40 (exp_aux2 -> term .)
    OR              reduce using rule 40 (exp_aux2 -> term .)
    AND             reduce using rule 40 (exp_aux2 -> term .)
    SEMICOLON       reduce using rule 40 (exp_aux2 -> term .)
    TO              reduce using rule 40 (exp_aux2 -> term .)
    RPAREN          reduce using rule 40 (exp_aux2 -> term .)
    COMA            reduce using rule 40 (exp_aux2 -> term .)


state 66

    (41) term -> factor . MULTIPLY term
    (42) term -> factor . DIVIDE term
    (43) term -> factor .

    MULTIPLY        shift and go to state 89
    DIVIDE          shift and go to state 90
    PLUS            reduce using rule 43 (term -> factor .)
    MINUS           reduce using rule 43 (term -> factor .)
    GREATERT        reduce using rule 43 (term -> factor .)
    LESST           reduce using rule 43 (term -> factor .)
    NOTEQUAL        reduce using rule 43 (term -> factor .)
    DBEQUALS        reduce using rule 43 (term -> factor .)
    OR              reduce using rule 43 (term -> factor .)
    AND             reduce using rule 43 (term -> factor .)
    SEMICOLON       reduce using rule 43 (term -> factor .)
    TO              reduce using rule 43 (term -> factor .)
    RPAREN          reduce using rule 43 (term -> factor .)
    COMA            reduce using rule 43 (term -> factor .)


state 67

    (44) factor -> LPAREN . expresion RPAREN
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    expresion                      shift and go to state 91
    exp                            shift and go to state 62
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 68

    (45) factor -> CTEINT .

    MULTIPLY        reduce using rule 45 (factor -> CTEINT .)
    DIVIDE          reduce using rule 45 (factor -> CTEINT .)
    PLUS            reduce using rule 45 (factor -> CTEINT .)
    MINUS           reduce using rule 45 (factor -> CTEINT .)
    GREATERT        reduce using rule 45 (factor -> CTEINT .)
    LESST           reduce using rule 45 (factor -> CTEINT .)
    NOTEQUAL        reduce using rule 45 (factor -> CTEINT .)
    DBEQUALS        reduce using rule 45 (factor -> CTEINT .)
    OR              reduce using rule 45 (factor -> CTEINT .)
    AND             reduce using rule 45 (factor -> CTEINT .)
    SEMICOLON       reduce using rule 45 (factor -> CTEINT .)
    TO              reduce using rule 45 (factor -> CTEINT .)
    RPAREN          reduce using rule 45 (factor -> CTEINT .)
    COMA            reduce using rule 45 (factor -> CTEINT .)


state 69

    (46) factor -> CTEF .

    MULTIPLY        reduce using rule 46 (factor -> CTEF .)
    DIVIDE          reduce using rule 46 (factor -> CTEF .)
    PLUS            reduce using rule 46 (factor -> CTEF .)
    MINUS           reduce using rule 46 (factor -> CTEF .)
    GREATERT        reduce using rule 46 (factor -> CTEF .)
    LESST           reduce using rule 46 (factor -> CTEF .)
    NOTEQUAL        reduce using rule 46 (factor -> CTEF .)
    DBEQUALS        reduce using rule 46 (factor -> CTEF .)
    OR              reduce using rule 46 (factor -> CTEF .)
    AND             reduce using rule 46 (factor -> CTEF .)
    SEMICOLON       reduce using rule 46 (factor -> CTEF .)
    TO              reduce using rule 46 (factor -> CTEF .)
    RPAREN          reduce using rule 46 (factor -> CTEF .)
    COMA            reduce using rule 46 (factor -> CTEF .)


state 70

    (47) factor -> ID .

    MULTIPLY        reduce using rule 47 (factor -> ID .)
    DIVIDE          reduce using rule 47 (factor -> ID .)
    PLUS            reduce using rule 47 (factor -> ID .)
    MINUS           reduce using rule 47 (factor -> ID .)
    GREATERT        reduce using rule 47 (factor -> ID .)
    LESST           reduce using rule 47 (factor -> ID .)
    NOTEQUAL        reduce using rule 47 (factor -> ID .)
    DBEQUALS        reduce using rule 47 (factor -> ID .)
    OR              reduce using rule 47 (factor -> ID .)
    AND             reduce using rule 47 (factor -> ID .)
    SEMICOLON       reduce using rule 47 (factor -> ID .)
    TO              reduce using rule 47 (factor -> ID .)
    RPAREN          reduce using rule 47 (factor -> ID .)
    COMA            reduce using rule 47 (factor -> ID .)


state 71

    (53) for -> FOR asignacion . TO CTEINT LBRACKET estatuto RBRACKET

    TO              shift and go to state 92


state 72

    (54) while -> WHILE LPAREN . expresion RPAREN LBRACKET estatuto RBRACKET
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    expresion                      shift and go to state 93
    exp                            shift and go to state 62
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 73

    (9) vars_aux2 -> ID n_seen_var_name COLON tipo . n_set_var_type SEMICOLON
    (65) n_set_var_type -> .

    SEMICOLON       reduce using rule 65 (n_set_var_type -> .)

    n_set_var_type                 shift and go to state 94

state 74

    (48) module -> MODULE VOID n_seen_type ID n_seen_func_name . LPAREN RPAREN bloque_module module
    (50) module -> MODULE VOID n_seen_type ID n_seen_func_name . LPAREN RPAREN bloque_module

    LPAREN          shift and go to state 95


state 75

    (49) module -> MODULE tipo ID n_seen_func_name LPAREN . RPAREN bloque_module module
    (51) module -> MODULE tipo ID n_seen_func_name LPAREN . RPAREN bloque_module

    RPAREN          shift and go to state 96


state 76

    (28) asignacion -> ID EQUAL expresion .

    SEMICOLON       reduce using rule 28 (asignacion -> ID EQUAL expresion .)
    TO              reduce using rule 28 (asignacion -> ID EQUAL expresion .)


state 77

    (55) condicion -> IF LPAREN expresion . RPAREN bloque ELSE bloque
    (56) condicion -> IF LPAREN expresion . RPAREN bloque

    RPAREN          shift and go to state 97


state 78

    (57) escritura -> PRINT LPAREN escritura_aux . RPAREN

    RPAREN          shift and go to state 98


state 79

    (58) escritura_aux -> expresion . COMA escritura_aux
    (60) escritura_aux -> expresion .

    COMA            shift and go to state 99
    RPAREN          reduce using rule 60 (escritura_aux -> expresion .)


state 80

    (59) escritura_aux -> CTESTRING . COMA escritura_aux
    (61) escritura_aux -> CTESTRING .

    COMA            shift and go to state 100
    RPAREN          reduce using rule 61 (escritura_aux -> CTESTRING .)


state 81

    (29) expresion -> exp AND . expresion
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    exp                            shift and go to state 62
    expresion                      shift and go to state 101
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 82

    (31) exp -> exp_aux OR . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    exp_aux                        shift and go to state 63
    exp                            shift and go to state 102
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 83

    (33) exp_aux -> exp_aux2 GREATERT . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    exp_aux2                       shift and go to state 103
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 84

    (34) exp_aux -> exp_aux2 LESST . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    exp_aux2                       shift and go to state 104
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 85

    (35) exp_aux -> exp_aux2 NOTEQUAL . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    exp_aux2                       shift and go to state 105
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 86

    (36) exp_aux -> exp_aux2 DBEQUALS . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    exp_aux2                       shift and go to state 106
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 87

    (38) exp_aux2 -> term PLUS . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    term                           shift and go to state 65
    exp_aux2                       shift and go to state 107
    factor                         shift and go to state 66

state 88

    (39) exp_aux2 -> term MINUS . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    term                           shift and go to state 65
    exp_aux2                       shift and go to state 108
    factor                         shift and go to state 66

state 89

    (41) term -> factor MULTIPLY . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    factor                         shift and go to state 66
    term                           shift and go to state 109

state 90

    (42) term -> factor DIVIDE . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    factor                         shift and go to state 66
    term                           shift and go to state 110

state 91

    (44) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 111


state 92

    (53) for -> FOR asignacion TO . CTEINT LBRACKET estatuto RBRACKET

    CTEINT          shift and go to state 112


state 93

    (54) while -> WHILE LPAREN expresion . RPAREN LBRACKET estatuto RBRACKET

    RPAREN          shift and go to state 113


state 94

    (9) vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type . SEMICOLON

    SEMICOLON       shift and go to state 114


state 95

    (48) module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN . RPAREN bloque_module module
    (50) module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN . RPAREN bloque_module

    RPAREN          shift and go to state 115


state 96

    (49) module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN . bloque_module module
    (51) module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN . bloque_module
    (12) bloque_module -> . LBRACKET estatuto_module_aux RBRACKET
    (13) bloque_module -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 22

    bloque_module                  shift and go to state 116

state 97

    (55) condicion -> IF LPAREN expresion RPAREN . bloque ELSE bloque
    (56) condicion -> IF LPAREN expresion RPAREN . bloque
    (18) bloque -> . LBRACKET estatuto_aux RBRACKET
    (19) bloque -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 118

    bloque                         shift and go to state 117

state 98

    (57) escritura -> PRINT LPAREN escritura_aux RPAREN .

    SEMICOLON       reduce using rule 57 (escritura -> PRINT LPAREN escritura_aux RPAREN .)


state 99

    (58) escritura_aux -> expresion COMA . escritura_aux
    (58) escritura_aux -> . expresion COMA escritura_aux
    (59) escritura_aux -> . CTESTRING COMA escritura_aux
    (60) escritura_aux -> . expresion
    (61) escritura_aux -> . CTESTRING
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    CTESTRING       shift and go to state 80
    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    expresion                      shift and go to state 79
    escritura_aux                  shift and go to state 119
    exp                            shift and go to state 62
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 100

    (59) escritura_aux -> CTESTRING COMA . escritura_aux
    (58) escritura_aux -> . expresion COMA escritura_aux
    (59) escritura_aux -> . CTESTRING COMA escritura_aux
    (60) escritura_aux -> . expresion
    (61) escritura_aux -> . CTESTRING
    (29) expresion -> . exp AND expresion
    (30) expresion -> . exp
    (31) exp -> . exp_aux OR exp
    (32) exp -> . exp_aux
    (33) exp_aux -> . exp_aux2 GREATERT exp_aux2
    (34) exp_aux -> . exp_aux2 LESST exp_aux2
    (35) exp_aux -> . exp_aux2 NOTEQUAL exp_aux2
    (36) exp_aux -> . exp_aux2 DBEQUALS exp_aux2
    (37) exp_aux -> . exp_aux2
    (38) exp_aux2 -> . term PLUS exp_aux2
    (39) exp_aux2 -> . term MINUS exp_aux2
    (40) exp_aux2 -> . term
    (41) term -> . factor MULTIPLY term
    (42) term -> . factor DIVIDE term
    (43) term -> . factor
    (44) factor -> . LPAREN expresion RPAREN
    (45) factor -> . CTEINT
    (46) factor -> . CTEF
    (47) factor -> . ID

    CTESTRING       shift and go to state 80
    LPAREN          shift and go to state 67
    CTEINT          shift and go to state 68
    CTEF            shift and go to state 69
    ID              shift and go to state 70

    escritura_aux                  shift and go to state 120
    expresion                      shift and go to state 79
    exp                            shift and go to state 62
    exp_aux                        shift and go to state 63
    exp_aux2                       shift and go to state 64
    term                           shift and go to state 65
    factor                         shift and go to state 66

state 101

    (29) expresion -> exp AND expresion .

    SEMICOLON       reduce using rule 29 (expresion -> exp AND expresion .)
    TO              reduce using rule 29 (expresion -> exp AND expresion .)
    RPAREN          reduce using rule 29 (expresion -> exp AND expresion .)
    COMA            reduce using rule 29 (expresion -> exp AND expresion .)


state 102

    (31) exp -> exp_aux OR exp .

    AND             reduce using rule 31 (exp -> exp_aux OR exp .)
    SEMICOLON       reduce using rule 31 (exp -> exp_aux OR exp .)
    TO              reduce using rule 31 (exp -> exp_aux OR exp .)
    RPAREN          reduce using rule 31 (exp -> exp_aux OR exp .)
    COMA            reduce using rule 31 (exp -> exp_aux OR exp .)


state 103

    (33) exp_aux -> exp_aux2 GREATERT exp_aux2 .

    OR              reduce using rule 33 (exp_aux -> exp_aux2 GREATERT exp_aux2 .)
    AND             reduce using rule 33 (exp_aux -> exp_aux2 GREATERT exp_aux2 .)
    SEMICOLON       reduce using rule 33 (exp_aux -> exp_aux2 GREATERT exp_aux2 .)
    TO              reduce using rule 33 (exp_aux -> exp_aux2 GREATERT exp_aux2 .)
    RPAREN          reduce using rule 33 (exp_aux -> exp_aux2 GREATERT exp_aux2 .)
    COMA            reduce using rule 33 (exp_aux -> exp_aux2 GREATERT exp_aux2 .)


state 104

    (34) exp_aux -> exp_aux2 LESST exp_aux2 .

    OR              reduce using rule 34 (exp_aux -> exp_aux2 LESST exp_aux2 .)
    AND             reduce using rule 34 (exp_aux -> exp_aux2 LESST exp_aux2 .)
    SEMICOLON       reduce using rule 34 (exp_aux -> exp_aux2 LESST exp_aux2 .)
    TO              reduce using rule 34 (exp_aux -> exp_aux2 LESST exp_aux2 .)
    RPAREN          reduce using rule 34 (exp_aux -> exp_aux2 LESST exp_aux2 .)
    COMA            reduce using rule 34 (exp_aux -> exp_aux2 LESST exp_aux2 .)


state 105

    (35) exp_aux -> exp_aux2 NOTEQUAL exp_aux2 .

    OR              reduce using rule 35 (exp_aux -> exp_aux2 NOTEQUAL exp_aux2 .)
    AND             reduce using rule 35 (exp_aux -> exp_aux2 NOTEQUAL exp_aux2 .)
    SEMICOLON       reduce using rule 35 (exp_aux -> exp_aux2 NOTEQUAL exp_aux2 .)
    TO              reduce using rule 35 (exp_aux -> exp_aux2 NOTEQUAL exp_aux2 .)
    RPAREN          reduce using rule 35 (exp_aux -> exp_aux2 NOTEQUAL exp_aux2 .)
    COMA            reduce using rule 35 (exp_aux -> exp_aux2 NOTEQUAL exp_aux2 .)


state 106

    (36) exp_aux -> exp_aux2 DBEQUALS exp_aux2 .

    OR              reduce using rule 36 (exp_aux -> exp_aux2 DBEQUALS exp_aux2 .)
    AND             reduce using rule 36 (exp_aux -> exp_aux2 DBEQUALS exp_aux2 .)
    SEMICOLON       reduce using rule 36 (exp_aux -> exp_aux2 DBEQUALS exp_aux2 .)
    TO              reduce using rule 36 (exp_aux -> exp_aux2 DBEQUALS exp_aux2 .)
    RPAREN          reduce using rule 36 (exp_aux -> exp_aux2 DBEQUALS exp_aux2 .)
    COMA            reduce using rule 36 (exp_aux -> exp_aux2 DBEQUALS exp_aux2 .)


state 107

    (38) exp_aux2 -> term PLUS exp_aux2 .

    GREATERT        reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    LESST           reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    NOTEQUAL        reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    DBEQUALS        reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    OR              reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    AND             reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    SEMICOLON       reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    TO              reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    RPAREN          reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)
    COMA            reduce using rule 38 (exp_aux2 -> term PLUS exp_aux2 .)


state 108

    (39) exp_aux2 -> term MINUS exp_aux2 .

    GREATERT        reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    LESST           reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    NOTEQUAL        reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    DBEQUALS        reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    OR              reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    AND             reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    SEMICOLON       reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    TO              reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    RPAREN          reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)
    COMA            reduce using rule 39 (exp_aux2 -> term MINUS exp_aux2 .)


state 109

    (41) term -> factor MULTIPLY term .

    PLUS            reduce using rule 41 (term -> factor MULTIPLY term .)
    MINUS           reduce using rule 41 (term -> factor MULTIPLY term .)
    GREATERT        reduce using rule 41 (term -> factor MULTIPLY term .)
    LESST           reduce using rule 41 (term -> factor MULTIPLY term .)
    NOTEQUAL        reduce using rule 41 (term -> factor MULTIPLY term .)
    DBEQUALS        reduce using rule 41 (term -> factor MULTIPLY term .)
    OR              reduce using rule 41 (term -> factor MULTIPLY term .)
    AND             reduce using rule 41 (term -> factor MULTIPLY term .)
    SEMICOLON       reduce using rule 41 (term -> factor MULTIPLY term .)
    TO              reduce using rule 41 (term -> factor MULTIPLY term .)
    RPAREN          reduce using rule 41 (term -> factor MULTIPLY term .)
    COMA            reduce using rule 41 (term -> factor MULTIPLY term .)


state 110

    (42) term -> factor DIVIDE term .

    PLUS            reduce using rule 42 (term -> factor DIVIDE term .)
    MINUS           reduce using rule 42 (term -> factor DIVIDE term .)
    GREATERT        reduce using rule 42 (term -> factor DIVIDE term .)
    LESST           reduce using rule 42 (term -> factor DIVIDE term .)
    NOTEQUAL        reduce using rule 42 (term -> factor DIVIDE term .)
    DBEQUALS        reduce using rule 42 (term -> factor DIVIDE term .)
    OR              reduce using rule 42 (term -> factor DIVIDE term .)
    AND             reduce using rule 42 (term -> factor DIVIDE term .)
    SEMICOLON       reduce using rule 42 (term -> factor DIVIDE term .)
    TO              reduce using rule 42 (term -> factor DIVIDE term .)
    RPAREN          reduce using rule 42 (term -> factor DIVIDE term .)
    COMA            reduce using rule 42 (term -> factor DIVIDE term .)


state 111

    (44) factor -> LPAREN expresion RPAREN .

    MULTIPLY        reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    GREATERT        reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    LESST           reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    NOTEQUAL        reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    DBEQUALS        reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    OR              reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    AND             reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    SEMICOLON       reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    TO              reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 44 (factor -> LPAREN expresion RPAREN .)
    COMA            reduce using rule 44 (factor -> LPAREN expresion RPAREN .)


state 112

    (53) for -> FOR asignacion TO CTEINT . LBRACKET estatuto RBRACKET

    LBRACKET        shift and go to state 121


state 113

    (54) while -> WHILE LPAREN expresion RPAREN . LBRACKET estatuto RBRACKET

    LBRACKET        shift and go to state 122


state 114

    (9) vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .

    ID              reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    MODULE          reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    MAIN            reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    VAR             reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    IF              reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    PRINT           reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    RETURN          reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    FOR             reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    WHILE           reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)
    RBRACKET        reduce using rule 9 (vars_aux2 -> ID n_seen_var_name COLON tipo n_set_var_type SEMICOLON .)


state 115

    (48) module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN . bloque_module module
    (50) module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN . bloque_module
    (12) bloque_module -> . LBRACKET estatuto_module_aux RBRACKET
    (13) bloque_module -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 22

    bloque_module                  shift and go to state 123

state 116

    (49) module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module . module
    (51) module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module .
    (48) module -> . MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module
    (49) module -> . MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module module
    (50) module -> . MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module
    (51) module -> . MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module

    MAIN            reduce using rule 51 (module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module .)
    MODULE          shift and go to state 9

    module                         shift and go to state 124

state 117

    (55) condicion -> IF LPAREN expresion RPAREN bloque . ELSE bloque
    (56) condicion -> IF LPAREN expresion RPAREN bloque .

    ELSE            shift and go to state 125
    SEMICOLON       reduce using rule 56 (condicion -> IF LPAREN expresion RPAREN bloque .)


state 118

    (18) bloque -> LBRACKET . estatuto_aux RBRACKET
    (19) bloque -> LBRACKET . RBRACKET
    (20) estatuto_aux -> . estatuto estatuto_aux
    (21) estatuto_aux -> . estatuto
    (22) estatuto -> . asignacion SEMICOLON
    (23) estatuto -> . condicion SEMICOLON
    (24) estatuto -> . escritura SEMICOLON
    (25) estatuto -> . return SEMICOLON
    (26) estatuto -> . for SEMICOLON
    (27) estatuto -> . while SEMICOLON
    (28) asignacion -> . ID EQUAL expresion
    (55) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque
    (56) condicion -> . IF LPAREN expresion RPAREN bloque
    (57) escritura -> . PRINT LPAREN escritura_aux RPAREN
    (52) return -> . RETURN expresion
    (53) for -> . FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET
    (54) while -> . WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET

    RBRACKET        shift and go to state 127
    ID              shift and go to state 41
    IF              shift and go to state 42
    PRINT           shift and go to state 43
    RETURN          shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    estatuto_aux                   shift and go to state 126
    estatuto                       shift and go to state 128
    asignacion                     shift and go to state 35
    condicion                      shift and go to state 36
    escritura                      shift and go to state 37
    return                         shift and go to state 38
    for                            shift and go to state 39
    while                          shift and go to state 40

state 119

    (58) escritura_aux -> expresion COMA escritura_aux .

    RPAREN          reduce using rule 58 (escritura_aux -> expresion COMA escritura_aux .)


state 120

    (59) escritura_aux -> CTESTRING COMA escritura_aux .

    RPAREN          reduce using rule 59 (escritura_aux -> CTESTRING COMA escritura_aux .)


state 121

    (53) for -> FOR asignacion TO CTEINT LBRACKET . estatuto RBRACKET
    (22) estatuto -> . asignacion SEMICOLON
    (23) estatuto -> . condicion SEMICOLON
    (24) estatuto -> . escritura SEMICOLON
    (25) estatuto -> . return SEMICOLON
    (26) estatuto -> . for SEMICOLON
    (27) estatuto -> . while SEMICOLON
    (28) asignacion -> . ID EQUAL expresion
    (55) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque
    (56) condicion -> . IF LPAREN expresion RPAREN bloque
    (57) escritura -> . PRINT LPAREN escritura_aux RPAREN
    (52) return -> . RETURN expresion
    (53) for -> . FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET
    (54) while -> . WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET

    ID              shift and go to state 41
    IF              shift and go to state 42
    PRINT           shift and go to state 43
    RETURN          shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    asignacion                     shift and go to state 35
    estatuto                       shift and go to state 129
    condicion                      shift and go to state 36
    escritura                      shift and go to state 37
    return                         shift and go to state 38
    for                            shift and go to state 39
    while                          shift and go to state 40

state 122

    (54) while -> WHILE LPAREN expresion RPAREN LBRACKET . estatuto RBRACKET
    (22) estatuto -> . asignacion SEMICOLON
    (23) estatuto -> . condicion SEMICOLON
    (24) estatuto -> . escritura SEMICOLON
    (25) estatuto -> . return SEMICOLON
    (26) estatuto -> . for SEMICOLON
    (27) estatuto -> . while SEMICOLON
    (28) asignacion -> . ID EQUAL expresion
    (55) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque
    (56) condicion -> . IF LPAREN expresion RPAREN bloque
    (57) escritura -> . PRINT LPAREN escritura_aux RPAREN
    (52) return -> . RETURN expresion
    (53) for -> . FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET
    (54) while -> . WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET

    ID              shift and go to state 41
    IF              shift and go to state 42
    PRINT           shift and go to state 43
    RETURN          shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    estatuto                       shift and go to state 130
    asignacion                     shift and go to state 35
    condicion                      shift and go to state 36
    escritura                      shift and go to state 37
    return                         shift and go to state 38
    for                            shift and go to state 39
    while                          shift and go to state 40

state 123

    (48) module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module . module
    (50) module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module .
    (48) module -> . MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module
    (49) module -> . MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module module
    (50) module -> . MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module
    (51) module -> . MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module

    MAIN            reduce using rule 50 (module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module .)
    MODULE          shift and go to state 9

    module                         shift and go to state 131

state 124

    (49) module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module module .

    MAIN            reduce using rule 49 (module -> MODULE tipo ID n_seen_func_name LPAREN RPAREN bloque_module module .)


state 125

    (55) condicion -> IF LPAREN expresion RPAREN bloque ELSE . bloque
    (18) bloque -> . LBRACKET estatuto_aux RBRACKET
    (19) bloque -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 118

    bloque                         shift and go to state 132

state 126

    (18) bloque -> LBRACKET estatuto_aux . RBRACKET

    RBRACKET        shift and go to state 133


state 127

    (19) bloque -> LBRACKET RBRACKET .

    ELSE            reduce using rule 19 (bloque -> LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 19 (bloque -> LBRACKET RBRACKET .)


state 128

    (20) estatuto_aux -> estatuto . estatuto_aux
    (21) estatuto_aux -> estatuto .
    (20) estatuto_aux -> . estatuto estatuto_aux
    (21) estatuto_aux -> . estatuto
    (22) estatuto -> . asignacion SEMICOLON
    (23) estatuto -> . condicion SEMICOLON
    (24) estatuto -> . escritura SEMICOLON
    (25) estatuto -> . return SEMICOLON
    (26) estatuto -> . for SEMICOLON
    (27) estatuto -> . while SEMICOLON
    (28) asignacion -> . ID EQUAL expresion
    (55) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque
    (56) condicion -> . IF LPAREN expresion RPAREN bloque
    (57) escritura -> . PRINT LPAREN escritura_aux RPAREN
    (52) return -> . RETURN expresion
    (53) for -> . FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET
    (54) while -> . WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET

    RBRACKET        reduce using rule 21 (estatuto_aux -> estatuto .)
    ID              shift and go to state 41
    IF              shift and go to state 42
    PRINT           shift and go to state 43
    RETURN          shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    estatuto                       shift and go to state 128
    estatuto_aux                   shift and go to state 134
    asignacion                     shift and go to state 35
    condicion                      shift and go to state 36
    escritura                      shift and go to state 37
    return                         shift and go to state 38
    for                            shift and go to state 39
    while                          shift and go to state 40

state 129

    (53) for -> FOR asignacion TO CTEINT LBRACKET estatuto . RBRACKET

    RBRACKET        shift and go to state 135


state 130

    (54) while -> WHILE LPAREN expresion RPAREN LBRACKET estatuto . RBRACKET

    RBRACKET        shift and go to state 136


state 131

    (48) module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module .

    MAIN            reduce using rule 48 (module -> MODULE VOID n_seen_type ID n_seen_func_name LPAREN RPAREN bloque_module module .)


state 132

    (55) condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque .

    SEMICOLON       reduce using rule 55 (condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque .)


state 133

    (18) bloque -> LBRACKET estatuto_aux RBRACKET .

    ELSE            reduce using rule 18 (bloque -> LBRACKET estatuto_aux RBRACKET .)
    SEMICOLON       reduce using rule 18 (bloque -> LBRACKET estatuto_aux RBRACKET .)


state 134

    (20) estatuto_aux -> estatuto estatuto_aux .

    RBRACKET        reduce using rule 20 (estatuto_aux -> estatuto estatuto_aux .)


state 135

    (53) for -> FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET .

    SEMICOLON       reduce using rule 53 (for -> FOR asignacion TO CTEINT LBRACKET estatuto RBRACKET .)


state 136

    (54) while -> WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET .

    SEMICOLON       reduce using rule 54 (while -> WHILE LPAREN expresion RPAREN LBRACKET estatuto RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 15 resolved as shift
